clc
clear all
close all

% komentowanie/odkomentowywanie: ctrl+r / ctrl+t

% Zadanie A
%------------------
d = 0.85;
N = 10;
density = 3; % parametr decydujacy o gestosci polaczen miedzy stronami
[edges] = generate_network(N, density);
%-----------------
% Zadanie B - generacja macierzy I, A, B i wektora b
B = sparse(edges(2,:),edges(1,:),1,N,N); % B -macierz sąsiedztwa
I = speye(N); % I - macierz jednostkowa
L = sum(B); % L liczba odnoścników wychodziących z i-tej strony
b = (1-d)/N * ones(N, 1); %b mają wartość (1 − d)/N, gdzie d jest współczynnikiem tłumienia.
A = spdiags(1./L',0:0,N,N); % macierz jednostkowa
%------------------
% macierze A, B i I musza byc przechowywane w formacie sparse (rzadkim)
whos('A', 'B', 'I')
%-----------------
% zadanie C
M = sparse(I - d * B * A);
r = M\b
r

% Zadanie E
%------------------
 clc
 clear all
 close all
 N = [500, 1000, 3000, 6000, 12000];
 density = 10; % parametr decydujacy o gestosci polaczen miedzy stronami
 d = 0.85;
 border = 10^(-14);
 for i = 1:5
     [edges] = generate_network(N(i), density);
     B = sparse(edges(2,:),edges(1,:),1,N(i),N(i)); % B -macierz sąsiedztwa
     I = speye(N(i)); % I - macierz jednostkowa
     L = sum(B); % L liczba odnoścników wychodziących z i-tej strony
     var = (1-d)/N(i);
     b =  ones(N(i), 1) * var;
     A = spdiags(1./L',0:0,N(i),N(i)); % macierz jednostkowa
     M = sparse(I - d * B * A);
     L = tril(M,-1) ;
     U = triu(M,1) ;
     D = diag(diag(M))
     r = ones(N(i),1);
     licznik(i) = 0;
     tic
     test = (L + U)*r
     test1 = D\b
     r = -D \(L + U)*r + D \ b

     czas_Jacobi(i) = toc;
 end
